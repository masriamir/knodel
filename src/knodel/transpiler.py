"""Utilities for exporting generated patterns as Tidal source code."""

from __future__ import annotations

from collections.abc import Callable
from dataclasses import dataclass
from importlib import import_module
from pathlib import Path

from .session import TidalSession


@dataclass
class TranspilerConfig:
    """Configuration settings for the Tidal transpiler."""

    header: str = "-- Generated by knodel"


class TidalTranspiler:
    """Transpile :class:`TidalSession` instances into Haskell code."""

    def __init__(self, config: TranspilerConfig | None = None) -> None:
        """Initialize a new transpiler.

        Args:
            config: Optional configuration overrides.
        """

        self._config = config or TranspilerConfig()

    def transpile(self, session: TidalSession) -> str:
        """Convert a session into its textual Tidal representation.

        Args:
            session: The session to transpile.

        Returns:
            The rendered Tidal source code.
        """

        lines = [self._config.header, session.to_tidal()]
        return "\n".join(line for line in lines if line)

    def write(self, session: TidalSession, destination: Path) -> None:
        """Write a transpiled session to disk.

        Args:
            session: The session to transpile.
            destination: The location to write the file.
        """

        destination.write_text(self.transpile(session), encoding="utf-8")


def load_session(path: str) -> TidalSession:
    """Load a ``TidalSession`` from a ``module:function`` string.

    Args:
        path: The import path in ``module:function`` format.

    Returns:
        The session created by the referenced factory.

    Raises:
        ValueError: If ``path`` is malformed.
    """

    module_path, _, attribute = path.partition(":")
    if not module_path or not attribute:
        raise ValueError("Session path must be in the form 'module:function'.")
    module = import_module(module_path)
    factory: Callable[[], TidalSession] = getattr(module, attribute)
    session = factory()
    if not isinstance(session, TidalSession):  # pragma: no cover - safety check
        raise TypeError("Factory did not return a TidalSession instance.")
    return session


__all__ = ["TidalTranspiler", "TranspilerConfig", "load_session"]
